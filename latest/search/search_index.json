{
    "docs": [
        {
            "location": "/", 
            "text": "Bifurcations.jl documentation\n\n\n\n\nExamples\n\n\nInterface\n\n\nInternals\n\n\nContinuation problem\n\n\nContinuation algorithm\n\n\nBifurcation problem", 
            "title": "Home"
        }, 
        {
            "location": "/#bifurcationsjl-documentation", 
            "text": "Examples  Interface  Internals  Continuation problem  Continuation algorithm  Bifurcation problem", 
            "title": "Bifurcations.jl documentation"
        }, 
        {
            "location": "/api/", 
            "text": "Interface\n\n\n#\n\n\nBifurcations.BifurcationsBase.BifurcationProblem\n \n \nType\n.\n\n\nBifurcationProblem(ode_or_map::AbstractODEProblem,\n                   param_axis::Lens,\n                   t_domain::Tuple;\n                   \nkeyword arguments\n)\n\n\n\n\nArguments\n\n\n\n\node_or_map\n: An \nODEProblem\n or \nDiscreteProblem\n.\n\n\nparam_axis :: Lens\n: The lens to set/get a parameter of \node_or_map\n.\n\n\nt_domain :: Tuple\n: A pair of numbers specifying the lower and upper bound for \nparam_axis\n.\n\n\n\n\nsource\n\n\nBifurcationProblem(point::AbstractSpecialPoint,\n                   solver::Codim1Solver,\n                   param_axis2::Lens,\n                   t2_domain::Tuple)\n\n\n\n\nConstruct codimension-2 bifurcation problem given a bifurcation \npoint\n.\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#interface", 
            "text": "#  Bifurcations.BifurcationsBase.BifurcationProblem     Type .  BifurcationProblem(ode_or_map::AbstractODEProblem,\n                   param_axis::Lens,\n                   t_domain::Tuple;\n                    keyword arguments )  Arguments   ode_or_map : An  ODEProblem  or  DiscreteProblem .  param_axis :: Lens : The lens to set/get a parameter of  ode_or_map .  t_domain :: Tuple : A pair of numbers specifying the lower and upper bound for  param_axis .   source  BifurcationProblem(point::AbstractSpecialPoint,\n                   solver::Codim1Solver,\n                   param_axis2::Lens,\n                   t2_domain::Tuple)  Construct codimension-2 bifurcation problem given a bifurcation  point .  source", 
            "title": "Interface"
        }, 
        {
            "location": "/internals/", 
            "text": "Internals\n\n\n\n\nContinuation problem\n\n\n#\n\n\nBifurcations.Continuations.AbstractContinuationProblem\n \n \nType\n.\n\n\nDefinition of continuation problem.\n\n\nNumerical continuation algorithms find curves in $\\mathbb R^{N}$ implicitly defined by\n\n\n\n\n\nH(u) = 0\n\n\n\n\n\nwhere $H: \\mathbb R^{N} \\to \\mathbb R^{N-1}$.\n\n\nA continuation problem type (a subtype of \nAbstractContinuationProblem\n) defines problems for such algorithms to solve by providing how to compute:\n\n\n\n\n$H(u)$: \nresidual\n, \nresidual!\n\n\nits derivative $\\partial H /  \\partial u$: \nresidual_jacobian!\n\n\nan initial guess $u_0$: \nget_u0\n\n\nand computation cache: \nget_prob_cache\n.\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.AbstractProblemCache\n \n \nType\n.\n\n\nAbstractProblemCache{P \n: AbstractContinuationProblem}\n\n\n\n\nCache for computing $H$ and its Jacobian.\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual\n \n \nFunction\n.\n\n\nresidual(u, cache) \u21a6 H\n\n\n\n\nCompute $H(u) \\in \\mathbb R^{N - 1}$ (aka in-place computation). The definition of $H$ is specified by \ncache\n.\n\n\nThe name \nresidual\n of the function is came from the problem we are to solve: i.e., find the set of $u$ such that $H(u) = 0$.  Thus, the vector returned by \nresidual(u, cache)\n is considered to be a residual.\n\n\nArguments\n\n\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual!\n \n \nFunction\n.\n\n\nresidual!(H, u, cache) \u21a6 H\n\n\n\n\nCompute $H(u) \\in \\mathbb R^{N - 1}$ and store the result in \nH\n (aka out-of-place computation). The definition of $H$ is specified by \ncache\n.\n\n\nSee also: \nresidual\n\n\nArguments\n\n\n\n\nH::AbstractVector\n (size: \n(N - 1,)\n)\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual_jacobian!\n \n \nFunction\n.\n\n\nresidual_jacobian!(H, J, u, cache) \u21a6 (H, J)\n\n\n\n\nCompute $H(u)$ and its Jacobian $\\partial H /  \\partial u$.\n\n\nArguments\n\n\n\n\nH::AbstractVector\n (size: \n(N - 1,)\n) $= H(u)$\n\n\nJ::AbstractMatrix\n (size: \n(N - 1, N)\n) $= \\partial H /  \\partial u$\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.isindomain\n \n \nFunction\n.\n\n\nisindomain(u, cache) :: Bool\n\n\n\n\nArguments\n\n\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.get_prob_cache\n \n \nFunction\n.\n\n\nget_prob_cache(prob::AbstractContinuationProblem) :: AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.get_u0\n \n \nFunction\n.\n\n\nget_u0(prob::AbstractContinuationProblem) \u21a6 u0\n\n\n\n\nsource\n\n\n\n\nContinuation algorithm\n\n\n#\n\n\nBifurcations.Continuations.ContinuationCache\n \n \nType\n.\n\n\nCache for Euler-Newton continuation method.\n\n\nSee \nAbstractContinuationProblem\n for the mathematical setup.\n\n\nFields\n\n\n\n\nprob_cache\n\n\nu\n (size: \n(N,)\n)\n\n\nH\n (size: \n(N - 1,)\n) $= H(u)$\n\n\nJ\n (size: \n(N - 1, N)\n) $= \\partial H / \\partial u$\n\n\nQ\n (size: \n(N - 1, N)\n): temporary array for the QR decomposition\n\n\nh::Real\n: step size\n\n\ndirection::Int\n: +1 or -1\n\n\ncorrector_success::Bool\n\n\nadaptation_success::Bool\n\n\nsimple_bifurcation::Bool\n\n\n\n\nsource\n\n\n\n\nBifurcation problem\n\n\n#\n\n\nBifurcations.FixedPointBifurcationProblem\n \n \nType\n.\n\n\nFixed point bifurcation problem.\n\n\nSee also: \nAbstractContinuationProblem\n\n\nFields\n\n\n\n\nhomotopy::Function\n: A function to compute $H(x, t)$ where $H$ is a homotopy $H: \\mathbb R^N \\times \\mathbb R \\to \\mathbb R^N$. Function \nhomotopy\n must be callable in one of the following form: \nhomotopy(x, p, t) \u21a6 H\n (return \nH\n) for mutable state type or \nhomotopy(H, x, p, t)\n (mutate \nH\n) for immutable state type.\n\n\nhomotopy_jacobian::Union{Function, Nothing}\n: A function to compute $H(x, t)$ and its Jacobian $J = \\partial H / \\partial (x, t) \\in \\mathbb R^{N \\times (N+1)}$. Function \nhomotopy_jacobian\n must be callable in one of the following form: \nhomotopy_jacobian(x, p, t) \u21a6 (H, J)\n (return \n(H, J)\n) or \nhomotopy_jacobian(H, J, x, p, t)\n (mutate \nH\n and \nJ\n).\n\n\nu0::Union{AbstractArray, Real}\n: Initial state.\n\n\nt0::Real\n: Initial parameter.\n\n\nt_domain::Tuple{\n:Real, \n:Real}\n: Range of the parameter.\n\n\nphase_space::Tuple{typeof(u0), typeof(u0)}\n: A pair of lower and upper bound of the phase space.  Default is unbounded.\n\n\np\n: Model parameter (constants).\n\n\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internals", 
            "text": "", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#continuation-problem", 
            "text": "#  Bifurcations.Continuations.AbstractContinuationProblem     Type .  Definition of continuation problem.  Numerical continuation algorithms find curves in $\\mathbb R^{N}$ implicitly defined by   \nH(u) = 0   where $H: \\mathbb R^{N} \\to \\mathbb R^{N-1}$.  A continuation problem type (a subtype of  AbstractContinuationProblem ) defines problems for such algorithms to solve by providing how to compute:   $H(u)$:  residual ,  residual!  its derivative $\\partial H /  \\partial u$:  residual_jacobian!  an initial guess $u_0$:  get_u0  and computation cache:  get_prob_cache .   source  #  Bifurcations.Continuations.AbstractProblemCache     Type .  AbstractProblemCache{P  : AbstractContinuationProblem}  Cache for computing $H$ and its Jacobian.  source  #  Bifurcations.Continuations.residual     Function .  residual(u, cache) \u21a6 H  Compute $H(u) \\in \\mathbb R^{N - 1}$ (aka in-place computation). The definition of $H$ is specified by  cache .  The name  residual  of the function is came from the problem we are to solve: i.e., find the set of $u$ such that $H(u) = 0$.  Thus, the vector returned by  residual(u, cache)  is considered to be a residual.  Arguments   u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.residual!     Function .  residual!(H, u, cache) \u21a6 H  Compute $H(u) \\in \\mathbb R^{N - 1}$ and store the result in  H  (aka out-of-place computation). The definition of $H$ is specified by  cache .  See also:  residual  Arguments   H::AbstractVector  (size:  (N - 1,) )  u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.residual_jacobian!     Function .  residual_jacobian!(H, J, u, cache) \u21a6 (H, J)  Compute $H(u)$ and its Jacobian $\\partial H /  \\partial u$.  Arguments   H::AbstractVector  (size:  (N - 1,) ) $= H(u)$  J::AbstractMatrix  (size:  (N - 1, N) ) $= \\partial H /  \\partial u$  u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.isindomain     Function .  isindomain(u, cache) :: Bool  Arguments   u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.get_prob_cache     Function .  get_prob_cache(prob::AbstractContinuationProblem) :: AbstractProblemCache  source  #  Bifurcations.Continuations.get_u0     Function .  get_u0(prob::AbstractContinuationProblem) \u21a6 u0  source", 
            "title": "Continuation problem"
        }, 
        {
            "location": "/internals/#continuation-algorithm", 
            "text": "#  Bifurcations.Continuations.ContinuationCache     Type .  Cache for Euler-Newton continuation method.  See  AbstractContinuationProblem  for the mathematical setup.  Fields   prob_cache  u  (size:  (N,) )  H  (size:  (N - 1,) ) $= H(u)$  J  (size:  (N - 1, N) ) $= \\partial H / \\partial u$  Q  (size:  (N - 1, N) ): temporary array for the QR decomposition  h::Real : step size  direction::Int : +1 or -1  corrector_success::Bool  adaptation_success::Bool  simple_bifurcation::Bool   source", 
            "title": "Continuation algorithm"
        }, 
        {
            "location": "/internals/#bifurcation-problem", 
            "text": "#  Bifurcations.FixedPointBifurcationProblem     Type .  Fixed point bifurcation problem.  See also:  AbstractContinuationProblem  Fields   homotopy::Function : A function to compute $H(x, t)$ where $H$ is a homotopy $H: \\mathbb R^N \\times \\mathbb R \\to \\mathbb R^N$. Function  homotopy  must be callable in one of the following form:  homotopy(x, p, t) \u21a6 H  (return  H ) for mutable state type or  homotopy(H, x, p, t)  (mutate  H ) for immutable state type.  homotopy_jacobian::Union{Function, Nothing} : A function to compute $H(x, t)$ and its Jacobian $J = \\partial H / \\partial (x, t) \\in \\mathbb R^{N \\times (N+1)}$. Function  homotopy_jacobian  must be callable in one of the following form:  homotopy_jacobian(x, p, t) \u21a6 (H, J)  (return  (H, J) ) or  homotopy_jacobian(H, J, x, p, t)  (mutate  H  and  J ).  u0::Union{AbstractArray, Real} : Initial state.  t0::Real : Initial parameter.  t_domain::Tuple{ :Real,  :Real} : Range of the parameter.  phase_space::Tuple{typeof(u0), typeof(u0)} : A pair of lower and upper bound of the phase space.  Default is unbounded.  p : Model parameter (constants).   source", 
            "title": "Bifurcation problem"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\n\n\nCalcium channel model", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Calcium channel model", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/calcium/", 
            "text": "Calcium channel model\n\n\nCalcium channel model taken from PyDSTool example.  See:\n\n\n\n\npydstool/Tutorial_Calcium.py at master \u00b7 robclewley/pydstool\n\n\nTutorial - PyDSTool Wiki\n\n\nBifurcation Analysis \u00b7 DifferentialEquations.jl\n\n\n\n\nUse \nQuickTypes.@qstruct_fp\n to define model parameter:\n\n\nusing QuickTypes: @qstruct_fp\n\n@qstruct_fp CalciumParam(\n    vl = -60,\n    vca = 120,\n    i = -220.0,\n    gl = 2,\n    gca = 4,\n    c = 20,\n    v1 = -1.2,\n    v2 = 18,\n)\n\n\n\n\nDefine the model as in \nDifferentialEquations.jl\n:\n\n\nusing Parameters: @unpack\n\nfunction f(u, p::CalciumParam, t)\n    @unpack vl, vca, i, gl, gca, c, v1, v2 = p\n    v = u[1]\n    w = u[2]\n    dv = (i + gl * (vl - v) - gca * 0.5 * (1 + tanh((v-v1)/v2)) * (v-vca)) / c\n    dw = v-w\n    return SVector(dv, dw)\nend\n\n\n\n\nf (generic function with 1 method)\n\n\n\n\nCreate an \nODEProblem\n:\n\n\nusing DiffEqBase: ODEProblem\nusing StaticArrays: SVector\n\nu0 = SVector(-170.0, -170.0)\ntspan = (0.0, 30.0)  # ignored by Bifurcations.jl\np = CalciumParam()\node = ODEProblem(f, u0, tspan, p)\n\n\n\n\nDiffEqBase.ODEProblem with uType StaticArrays.SArray{Tuple{2},Float64,1,2} and tType Float64. In-place: false\ntimespan: (0.0, 30.0)\nu0: [-170.0, -170.0]\n\n\n\n\nCreate a bifurcation problem:\n\n\nusing Bifurcations: BifurcationProblem\nusing Setfield: @lens\n\nparam_axis = @lens _.i\nprob = BifurcationProblem(ode, param_axis, (-300.0, 100.0))\n\n\n\n\nSolve it:\n\n\nusing DiffEqBase: init, solve!\n\nsolver = init(prob)\nsolve!(solver)\nsol = solver.sol\n\n\n\n\nCodim1Solution \nContinuous\n\n# sweeps             : 2\n# points             : 106\n# simple bifurcations: 0\n# special points     : 2\n\n\n\n\nPlot it:\n\n\nusing Plots\nusing Bifurcations: plot  # a workaround\n\nplt = plot(sol)\n\n\n\n\n\n\nFind the left Saddle-Node bifurcation point:\n\n\nusing Bifurcations: special_points\n\npoint_list = sort!(special_points(solver), by=p-\np.u0[end])\npoint = point_list[1]\n\n\n\n\nSpecialPointInterval \nContinuous saddle_node\n\nhappened between:\n  u0 = [15.36, 15.36, -210.476]\n  u1 = [15.822, 15.822, -210.44]\n\n\n\n\nNumerical continuation of the Saddle-Node bifurcation point:\n\n\nsn_prob = BifurcationProblem(\n    point,\n    solver,\n    (@lens _.gca),\n    (0.0, 8.0),\n)\nsn_solver = init(sn_prob)\nsolve!(sn_solver)\n\n\n\n\nCodim2Solver \nContinuous\n\n# sweeps             : 2\n# points             : 68\n# simple bifurcations: 0\n# special points     : 1\n\n\n\n\nPlot the phase diagram:\n\n\nplt2 = plot(sn_solver.sol)", 
            "title": "Calcium"
        }, 
        {
            "location": "/examples/calcium/#calcium-channel-model", 
            "text": "Calcium channel model taken from PyDSTool example.  See:   pydstool/Tutorial_Calcium.py at master \u00b7 robclewley/pydstool  Tutorial - PyDSTool Wiki  Bifurcation Analysis \u00b7 DifferentialEquations.jl   Use  QuickTypes.@qstruct_fp  to define model parameter:  using QuickTypes: @qstruct_fp\n\n@qstruct_fp CalciumParam(\n    vl = -60,\n    vca = 120,\n    i = -220.0,\n    gl = 2,\n    gca = 4,\n    c = 20,\n    v1 = -1.2,\n    v2 = 18,\n)  Define the model as in  DifferentialEquations.jl :  using Parameters: @unpack\n\nfunction f(u, p::CalciumParam, t)\n    @unpack vl, vca, i, gl, gca, c, v1, v2 = p\n    v = u[1]\n    w = u[2]\n    dv = (i + gl * (vl - v) - gca * 0.5 * (1 + tanh((v-v1)/v2)) * (v-vca)) / c\n    dw = v-w\n    return SVector(dv, dw)\nend  f (generic function with 1 method)  Create an  ODEProblem :  using DiffEqBase: ODEProblem\nusing StaticArrays: SVector\n\nu0 = SVector(-170.0, -170.0)\ntspan = (0.0, 30.0)  # ignored by Bifurcations.jl\np = CalciumParam()\node = ODEProblem(f, u0, tspan, p)  DiffEqBase.ODEProblem with uType StaticArrays.SArray{Tuple{2},Float64,1,2} and tType Float64. In-place: false\ntimespan: (0.0, 30.0)\nu0: [-170.0, -170.0]  Create a bifurcation problem:  using Bifurcations: BifurcationProblem\nusing Setfield: @lens\n\nparam_axis = @lens _.i\nprob = BifurcationProblem(ode, param_axis, (-300.0, 100.0))  Solve it:  using DiffEqBase: init, solve!\n\nsolver = init(prob)\nsolve!(solver)\nsol = solver.sol  Codim1Solution  Continuous \n# sweeps             : 2\n# points             : 106\n# simple bifurcations: 0\n# special points     : 2  Plot it:  using Plots\nusing Bifurcations: plot  # a workaround\n\nplt = plot(sol)   Find the left Saddle-Node bifurcation point:  using Bifurcations: special_points\n\npoint_list = sort!(special_points(solver), by=p- p.u0[end])\npoint = point_list[1]  SpecialPointInterval  Continuous saddle_node \nhappened between:\n  u0 = [15.36, 15.36, -210.476]\n  u1 = [15.822, 15.822, -210.44]  Numerical continuation of the Saddle-Node bifurcation point:  sn_prob = BifurcationProblem(\n    point,\n    solver,\n    (@lens _.gca),\n    (0.0, 8.0),\n)\nsn_solver = init(sn_prob)\nsolve!(sn_solver)  Codim2Solver  Continuous \n# sweeps             : 2\n# points             : 68\n# simple bifurcations: 0\n# special points     : 1  Plot the phase diagram:  plt2 = plot(sn_solver.sol)", 
            "title": "Calcium channel model"
        }
    ]
}