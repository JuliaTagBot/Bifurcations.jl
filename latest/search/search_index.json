{
    "docs": [
        {
            "location": "/", 
            "text": "Bifurcations.jl documentation\n\n\n\n\nExamples\n\n\nInterface\n\n\nInternals\n\n\nContinuation problem\n\n\nContinuation algorithm\n\n\nBifurcation problem", 
            "title": "Home"
        }, 
        {
            "location": "/#bifurcationsjl-documentation", 
            "text": "Examples  Interface  Internals  Continuation problem  Continuation algorithm  Bifurcation problem", 
            "title": "Bifurcations.jl documentation"
        }, 
        {
            "location": "/api/", 
            "text": "Interface\n\n\n#\n\n\nBifurcations.BifurcationsBase.BifurcationProblem\n \n \nType\n.\n\n\nBifurcationProblem(point::AbstractSpecialPoint,\n                   solver::Codim1Solver,\n                   param_axis2::Lens,\n                   t2_domain::Tuple)\n\n\n\n\nConstruct codimension-2 bifurcation problem given a bifurcation \npoint\n.\n\n\nsource\n\n\nBifurcationProblem(ode_or_map::AbstractODEProblem,\n                   param_axis::Lens,\n                   t_domain::Tuple;\n                   \nkeyword arguments\n)\n\n\n\n\nArguments\n\n\n\n\node_or_map\n: An \nODEProblem\n or \nDiscreteProblem\n.\n\n\nparam_axis :: Lens\n: The lens to set/get a parameter of \node_or_map\n.\n\n\nt_domain :: Tuple\n: A pair of numbers specifying the lower and upper bound for \nparam_axis\n.\n\n\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#interface", 
            "text": "#  Bifurcations.BifurcationsBase.BifurcationProblem     Type .  BifurcationProblem(point::AbstractSpecialPoint,\n                   solver::Codim1Solver,\n                   param_axis2::Lens,\n                   t2_domain::Tuple)  Construct codimension-2 bifurcation problem given a bifurcation  point .  source  BifurcationProblem(ode_or_map::AbstractODEProblem,\n                   param_axis::Lens,\n                   t_domain::Tuple;\n                    keyword arguments )  Arguments   ode_or_map : An  ODEProblem  or  DiscreteProblem .  param_axis :: Lens : The lens to set/get a parameter of  ode_or_map .  t_domain :: Tuple : A pair of numbers specifying the lower and upper bound for  param_axis .   source", 
            "title": "Interface"
        }, 
        {
            "location": "/internals/", 
            "text": "Internals\n\n\n\n\nContinuation problem\n\n\n#\n\n\nBifurcations.Continuations.AbstractContinuationProblem\n \n \nType\n.\n\n\nDefinition of continuation problem.\n\n\nNumerical continuation algorithms find curves in $\\mathbb R^{N}$ implicitly defined by\n\n\n\n\n\nH(u) = 0\n\n\n\n\n\nwhere $H: \\mathbb R^{N} \\to \\mathbb R^{N-1}$.\n\n\nA continuation problem type (a subtype of \nAbstractContinuationProblem\n) defines problems for such algorithms to solve by providing how to compute:\n\n\n\n\n$H(u)$: \nresidual\n, \nresidual!\n\n\nits derivative $\\partial H /  \\partial u$: \nresidual_jacobian!\n\n\nan initial guess $u_0$: \nget_u0\n\n\nand computation cache: \nget_prob_cache\n.\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.AbstractProblemCache\n \n \nType\n.\n\n\nAbstractProblemCache{P \n: AbstractContinuationProblem}\n\n\n\n\nCache for computing $H$ and its Jacobian.\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual\n \n \nFunction\n.\n\n\nresidual(u, cache) \u21a6 H\n\n\n\n\nCompute $H(u) \\in \\mathbb R^{N - 1}$ (aka in-place computation). The definition of $H$ is specified by \ncache\n.\n\n\nThe name \nresidual\n of the function is came from the problem we are to solve: i.e., find the set of $u$ such that $H(u) = 0$.  Thus, the vector returned by \nresidual(u, cache)\n is considered to be a residual.\n\n\nArguments\n\n\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual!\n \n \nFunction\n.\n\n\nresidual!(H, u, cache) \u21a6 H\n\n\n\n\nCompute $H(u) \\in \\mathbb R^{N - 1}$ and store the result in \nH\n (aka out-of-place computation). The definition of $H$ is specified by \ncache\n.\n\n\nSee also: \nresidual\n\n\nArguments\n\n\n\n\nH::AbstractVector\n (size: \n(N - 1,)\n)\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.residual_jacobian!\n \n \nFunction\n.\n\n\nresidual_jacobian!(H, J, u, cache) \u21a6 (H, J)\n\n\n\n\nCompute $H(u)$ and its Jacobian $\\partial H /  \\partial u$.\n\n\nArguments\n\n\n\n\nH::AbstractVector\n (size: \n(N - 1,)\n) $= H(u)$\n\n\nJ::AbstractMatrix\n (size: \n(N - 1, N)\n) $= \\partial H /  \\partial u$\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.isindomain\n \n \nFunction\n.\n\n\nisindomain(u, cache) :: Bool\n\n\n\n\nArguments\n\n\n\n\nu::AbstractVector\n (size: \n(N,)\n)\n\n\ncache::AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.get_prob_cache\n \n \nFunction\n.\n\n\nget_prob_cache(prob::AbstractContinuationProblem) :: AbstractProblemCache\n\n\n\n\nsource\n\n\n#\n\n\nBifurcations.Continuations.get_u0\n \n \nFunction\n.\n\n\nget_u0(prob::AbstractContinuationProblem) \u21a6 u0\n\n\n\n\nsource\n\n\n\n\nContinuation algorithm\n\n\n#\n\n\nBifurcations.Continuations.ContinuationCache\n \n \nType\n.\n\n\nCache for Euler-Newton continuation method.\n\n\nSee \nAbstractContinuationProblem\n for the mathematical setup.\n\n\nFields\n\n\n\n\nprob_cache\n\n\nu\n (size: \n(N,)\n)\n\n\nH\n (size: \n(N - 1,)\n) $= H(u)$\n\n\nJ\n (size: \n(N - 1, N)\n) $= \\partial H / \\partial u$\n\n\nQ\n (size: \n(N - 1, N)\n): temporary array for the QR decomposition\n\n\nh::Real\n: step size\n\n\ndirection::Int\n: +1 or -1\n\n\ncorrector_success::Bool\n\n\nadaptation_success::Bool\n\n\nsimple_bifurcation::Bool\n\n\n\n\nsource\n\n\n\n\nBifurcation problem\n\n\n#\n\n\nBifurcations.FixedPointBifurcationProblem\n \n \nType\n.\n\n\nFixed point bifurcation problem.\n\n\nSee also: \nAbstractContinuationProblem\n\n\nFields\n\n\n\n\nhomotopy::Function\n: A function to compute $H(x, t)$ where $H$ is a homotopy $H: \\mathbb R^N \\times \\mathbb R \\to \\mathbb R^N$. Function \nhomotopy\n must be callable in one of the following form: \nhomotopy(x, p, t) \u21a6 H\n (return \nH\n) for mutable state type or \nhomotopy(H, x, p, t)\n (mutate \nH\n) for immutable state type.\n\n\nhomotopy_jacobian::Union{Function, Nothing}\n: A function to compute $H(x, t)$ and its Jacobian $J = \\partial H / \\partial (x, t) \\in \\mathbb R^{N \\times (N+1)}$. Function \nhomotopy_jacobian\n must be callable in one of the following form: \nhomotopy_jacobian(x, p, t) \u21a6 (H, J)\n (return \n(H, J)\n) or \nhomotopy_jacobian(H, J, x, p, t)\n (mutate \nH\n and \nJ\n).\n\n\nu0::Union{AbstractArray, Real}\n: Initial state.\n\n\nt0::Real\n: Initial parameter.\n\n\nt_domain::Tuple{\n:Real, \n:Real}\n: Range of the parameter.\n\n\nphase_space::Tuple{typeof(u0), typeof(u0)}\n: A pair of lower and upper bound of the phase space.  Default is unbounded.\n\n\np\n: Model parameter (constants).\n\n\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internals", 
            "text": "", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#continuation-problem", 
            "text": "#  Bifurcations.Continuations.AbstractContinuationProblem     Type .  Definition of continuation problem.  Numerical continuation algorithms find curves in $\\mathbb R^{N}$ implicitly defined by   \nH(u) = 0   where $H: \\mathbb R^{N} \\to \\mathbb R^{N-1}$.  A continuation problem type (a subtype of  AbstractContinuationProblem ) defines problems for such algorithms to solve by providing how to compute:   $H(u)$:  residual ,  residual!  its derivative $\\partial H /  \\partial u$:  residual_jacobian!  an initial guess $u_0$:  get_u0  and computation cache:  get_prob_cache .   source  #  Bifurcations.Continuations.AbstractProblemCache     Type .  AbstractProblemCache{P  : AbstractContinuationProblem}  Cache for computing $H$ and its Jacobian.  source  #  Bifurcations.Continuations.residual     Function .  residual(u, cache) \u21a6 H  Compute $H(u) \\in \\mathbb R^{N - 1}$ (aka in-place computation). The definition of $H$ is specified by  cache .  The name  residual  of the function is came from the problem we are to solve: i.e., find the set of $u$ such that $H(u) = 0$.  Thus, the vector returned by  residual(u, cache)  is considered to be a residual.  Arguments   u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.residual!     Function .  residual!(H, u, cache) \u21a6 H  Compute $H(u) \\in \\mathbb R^{N - 1}$ and store the result in  H  (aka out-of-place computation). The definition of $H$ is specified by  cache .  See also:  residual  Arguments   H::AbstractVector  (size:  (N - 1,) )  u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.residual_jacobian!     Function .  residual_jacobian!(H, J, u, cache) \u21a6 (H, J)  Compute $H(u)$ and its Jacobian $\\partial H /  \\partial u$.  Arguments   H::AbstractVector  (size:  (N - 1,) ) $= H(u)$  J::AbstractMatrix  (size:  (N - 1, N) ) $= \\partial H /  \\partial u$  u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.isindomain     Function .  isindomain(u, cache) :: Bool  Arguments   u::AbstractVector  (size:  (N,) )  cache::AbstractProblemCache   source  #  Bifurcations.Continuations.get_prob_cache     Function .  get_prob_cache(prob::AbstractContinuationProblem) :: AbstractProblemCache  source  #  Bifurcations.Continuations.get_u0     Function .  get_u0(prob::AbstractContinuationProblem) \u21a6 u0  source", 
            "title": "Continuation problem"
        }, 
        {
            "location": "/internals/#continuation-algorithm", 
            "text": "#  Bifurcations.Continuations.ContinuationCache     Type .  Cache for Euler-Newton continuation method.  See  AbstractContinuationProblem  for the mathematical setup.  Fields   prob_cache  u  (size:  (N,) )  H  (size:  (N - 1,) ) $= H(u)$  J  (size:  (N - 1, N) ) $= \\partial H / \\partial u$  Q  (size:  (N - 1, N) ): temporary array for the QR decomposition  h::Real : step size  direction::Int : +1 or -1  corrector_success::Bool  adaptation_success::Bool  simple_bifurcation::Bool   source", 
            "title": "Continuation algorithm"
        }, 
        {
            "location": "/internals/#bifurcation-problem", 
            "text": "#  Bifurcations.FixedPointBifurcationProblem     Type .  Fixed point bifurcation problem.  See also:  AbstractContinuationProblem  Fields   homotopy::Function : A function to compute $H(x, t)$ where $H$ is a homotopy $H: \\mathbb R^N \\times \\mathbb R \\to \\mathbb R^N$. Function  homotopy  must be callable in one of the following form:  homotopy(x, p, t) \u21a6 H  (return  H ) for mutable state type or  homotopy(H, x, p, t)  (mutate  H ) for immutable state type.  homotopy_jacobian::Union{Function, Nothing} : A function to compute $H(x, t)$ and its Jacobian $J = \\partial H / \\partial (x, t) \\in \\mathbb R^{N \\times (N+1)}$. Function  homotopy_jacobian  must be callable in one of the following form:  homotopy_jacobian(x, p, t) \u21a6 (H, J)  (return  (H, J) ) or  homotopy_jacobian(H, J, x, p, t)  (mutate  H  and  J ).  u0::Union{AbstractArray, Real} : Initial state.  t0::Real : Initial parameter.  t_domain::Tuple{ :Real,  :Real} : Range of the parameter.  phase_space::Tuple{typeof(u0), typeof(u0)} : A pair of lower and upper bound of the phase space.  Default is unbounded.  p : Model parameter (constants).   source", 
            "title": "Bifurcation problem"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\n\n\nCalcium channel model\n\n\nContinuation of limit cycles of the van der Pol oscillator\n\n\nModified Morris-Lecar model", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Calcium channel model  Continuation of limit cycles of the van der Pol oscillator  Modified Morris-Lecar model", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/calcium/", 
            "text": "Calcium channel model\n\n\nCalcium channel model taken from PyDSTool example.  See:\n\n\n\n\npydstool/Tutorial_Calcium.py at master \u00b7 robclewley/pydstool\n\n\nTutorial - PyDSTool Wiki\n\n\nBifurcation Analysis \u00b7 DifferentialEquations.jl\n\n\n\n\nUse \nQuickTypes.@qstruct_fp\n to define model parameter:\n\n\nusing QuickTypes: @qstruct_fp\n\n@qstruct_fp CalciumParam(\n    vl = -60,\n    vca = 120,\n    i = -220.0,\n    gl = 2,\n    gca = 4,\n    c = 20,\n    v1 = -1.2,\n    v2 = 18,\n)\n\n\n\n\nDefine the model as in \nDifferentialEquations.jl\n:\n\n\nusing Parameters: @unpack\n\nfunction f(u, p::CalciumParam, t)\n    @unpack vl, vca, i, gl, gca, c, v1, v2 = p\n    v = u[1]\n    w = u[2]\n    dv = (i + gl * (vl - v) - gca * 0.5 * (1 + tanh((v-v1)/v2)) * (v-vca)) / c\n    dw = v-w\n    return SVector(dv, dw)\nend\n\n\n\n\nf (generic function with 1 method)\n\n\n\n\nCreate an \nODEProblem\n:\n\n\nusing DiffEqBase: ODEProblem\nusing StaticArrays: SVector\n\nu0 = SVector(-170.0, -170.0)\ntspan = (0.0, 30.0)  # ignored by Bifurcations.jl\np = CalciumParam()\node = ODEProblem(f, u0, tspan, p)\n\n\n\n\nODEProblem with uType StaticArrays.SArray{Tuple{2},Float64,1,2} and tType Float64. In-place: false\ntimespan: (0.0, 30.0)\nu0: [-170.0, -170.0]\n\n\n\n\nCreate a bifurcation problem:\n\n\nusing Bifurcations: BifurcationProblem\nusing Setfield: @lens\n\nparam_axis = @lens _.i\nprob = BifurcationProblem(ode, param_axis, (-300.0, 100.0))\n\n\n\n\nSolve it:\n\n\nusing DiffEqBase: init, solve!\n\nsolver = init(prob)\nsolve!(solver)\nsol = solver.sol\n\n\n\n\nCodim1Solution \nContinuous\n\n# sweeps             : 2\n# points             : 106\n# branches           : 0\n# saddle_node        : 2\n\n\n\n\nPlot it:\n\n\nusing Plots\n\nplt = plot(sol)\n\n\n\n\n\n\nFind the left Saddle-Node bifurcation point:\n\n\nusing Bifurcations: special_points\n\npoint_list = sort!(special_points(solver), by=p-\np.u0[end])\npoint = point_list[1]\n\n\n\n\nSpecialPointInterval \nContinuous saddle_node\n\nhappened between:\n  u0 = [15.36, 15.36, -210.476]\n  u1 = [15.822, 15.822, -210.44]\n\n\n\n\nNumerical continuation of the Saddle-Node bifurcation point:\n\n\nsn_prob = BifurcationProblem(\n    point,\n    solver,\n    (@lens _.gca),\n    (0.0, 8.0),\n)\nsn_solver = init(sn_prob)\nsolve!(sn_solver)\n\n\n\n\nCodim2Solver \nContinuous\n\n# sweeps             : 2\n# points             : 68\n# branches           : 0\n# cusp               : 1\n\n\n\n\nPlot the phase diagram:\n\n\nplt2 = plot(sn_solver.sol)", 
            "title": "Calcium"
        }, 
        {
            "location": "/examples/calcium/#calcium-channel-model", 
            "text": "Calcium channel model taken from PyDSTool example.  See:   pydstool/Tutorial_Calcium.py at master \u00b7 robclewley/pydstool  Tutorial - PyDSTool Wiki  Bifurcation Analysis \u00b7 DifferentialEquations.jl   Use  QuickTypes.@qstruct_fp  to define model parameter:  using QuickTypes: @qstruct_fp\n\n@qstruct_fp CalciumParam(\n    vl = -60,\n    vca = 120,\n    i = -220.0,\n    gl = 2,\n    gca = 4,\n    c = 20,\n    v1 = -1.2,\n    v2 = 18,\n)  Define the model as in  DifferentialEquations.jl :  using Parameters: @unpack\n\nfunction f(u, p::CalciumParam, t)\n    @unpack vl, vca, i, gl, gca, c, v1, v2 = p\n    v = u[1]\n    w = u[2]\n    dv = (i + gl * (vl - v) - gca * 0.5 * (1 + tanh((v-v1)/v2)) * (v-vca)) / c\n    dw = v-w\n    return SVector(dv, dw)\nend  f (generic function with 1 method)  Create an  ODEProblem :  using DiffEqBase: ODEProblem\nusing StaticArrays: SVector\n\nu0 = SVector(-170.0, -170.0)\ntspan = (0.0, 30.0)  # ignored by Bifurcations.jl\np = CalciumParam()\node = ODEProblem(f, u0, tspan, p)  ODEProblem with uType StaticArrays.SArray{Tuple{2},Float64,1,2} and tType Float64. In-place: false\ntimespan: (0.0, 30.0)\nu0: [-170.0, -170.0]  Create a bifurcation problem:  using Bifurcations: BifurcationProblem\nusing Setfield: @lens\n\nparam_axis = @lens _.i\nprob = BifurcationProblem(ode, param_axis, (-300.0, 100.0))  Solve it:  using DiffEqBase: init, solve!\n\nsolver = init(prob)\nsolve!(solver)\nsol = solver.sol  Codim1Solution  Continuous \n# sweeps             : 2\n# points             : 106\n# branches           : 0\n# saddle_node        : 2  Plot it:  using Plots\n\nplt = plot(sol)   Find the left Saddle-Node bifurcation point:  using Bifurcations: special_points\n\npoint_list = sort!(special_points(solver), by=p- p.u0[end])\npoint = point_list[1]  SpecialPointInterval  Continuous saddle_node \nhappened between:\n  u0 = [15.36, 15.36, -210.476]\n  u1 = [15.822, 15.822, -210.44]  Numerical continuation of the Saddle-Node bifurcation point:  sn_prob = BifurcationProblem(\n    point,\n    solver,\n    (@lens _.gca),\n    (0.0, 8.0),\n)\nsn_solver = init(sn_prob)\nsolve!(sn_solver)  Codim2Solver  Continuous \n# sweeps             : 2\n# points             : 68\n# branches           : 0\n# cusp               : 1  Plot the phase diagram:  plt2 = plot(sn_solver.sol)", 
            "title": "Calcium channel model"
        }, 
        {
            "location": "/examples/van_der_pol/", 
            "text": "Continuation of limit cycles of the van der Pol oscillator\n\n\nusing Bifurcations\nusing Bifurcations: LimitCycleProblem\nusing Bifurcations.Examples.DuffingVanDerPol\n\nusing Plots\nusing OrdinaryDiffEq: Tsit5, remake\n\n\n\n\nCreate an \nODEProblem\n and solve it:\n\n\node = remake(\n    DuffingVanDerPol.ode,\n    p = DuffingVanDerPol.DuffingVanDerPolParam(\n        d = 0.1,\n    ),\n    u0 = [1.0, 1.8],\n    tspan = (0.0, 90),\n)\nsol = solve(ode, Tsit5())\n\nplt_ode = plot(sol, vars=1, tspan=(70, 90))\n\n\n\n\n\n\nLet's find a point (approximately) on the limit cycle and its period:\n\n\nusing Roots: find_zero\nt0 = find_zero((t) -\n sol(t)[1] - 1, (80, 83))\nt1 = find_zero((t) -\n sol(t)[1] - 1, (t0 + 3, t0 + 7))\nx0 = sol(t0)\n@assert all(isapprox.(x0, sol(t1); rtol=1e-2))\nx0\n\n\n\n\n2-element Array{Float64,1}:\n 0.9999999999999799\n 1.8229006727041834\n\n\n\n\nThen a \nLimitCycleProblem\n can be constructed from the \node\n.\n\n\nnum_mesh = 50\ndegree = 5\nt_domain = (0.01, 4.0)  # so that it works with this `num_mesh` / `degree`\nprob = LimitCycleProblem(\n    ode, DuffingVanDerPol.param_axis, t_domain,\n    num_mesh, degree;\n    x0 = x0,\n    l0 = t1 - t0,\n    de_args = [Tsit5()],\n)\n\n\n\n\nAs the limit cycle is only approximately specified, solver option \nstart_from_nearest_root = true\n must be passed to start continuation:\n\n\nsolver = init(\n    prob;\n    start_from_nearest_root = true,\n)\n@time solve!(solver)\n\n\n\n\n372.495524 seconds (9.02 M allocations: 1.285 GiB, 0.93% gc time)\nBifurcationSolver \nContinuous\n\n# sweeps             : 2\n# points             : 35\n# branches           : 0\n\n\n\n\nBy default, \nplot_state_space\n plots limit cycles colored by its period:\n\n\nplt_lc = plot_state_space(solver)", 
            "title": "Van der pol"
        }, 
        {
            "location": "/examples/van_der_pol/#continuation-of-limit-cycles-of-the-van-der-pol-oscillator", 
            "text": "using Bifurcations\nusing Bifurcations: LimitCycleProblem\nusing Bifurcations.Examples.DuffingVanDerPol\n\nusing Plots\nusing OrdinaryDiffEq: Tsit5, remake  Create an  ODEProblem  and solve it:  ode = remake(\n    DuffingVanDerPol.ode,\n    p = DuffingVanDerPol.DuffingVanDerPolParam(\n        d = 0.1,\n    ),\n    u0 = [1.0, 1.8],\n    tspan = (0.0, 90),\n)\nsol = solve(ode, Tsit5())\n\nplt_ode = plot(sol, vars=1, tspan=(70, 90))   Let's find a point (approximately) on the limit cycle and its period:  using Roots: find_zero\nt0 = find_zero((t) -  sol(t)[1] - 1, (80, 83))\nt1 = find_zero((t) -  sol(t)[1] - 1, (t0 + 3, t0 + 7))\nx0 = sol(t0)\n@assert all(isapprox.(x0, sol(t1); rtol=1e-2))\nx0  2-element Array{Float64,1}:\n 0.9999999999999799\n 1.8229006727041834  Then a  LimitCycleProblem  can be constructed from the  ode .  num_mesh = 50\ndegree = 5\nt_domain = (0.01, 4.0)  # so that it works with this `num_mesh` / `degree`\nprob = LimitCycleProblem(\n    ode, DuffingVanDerPol.param_axis, t_domain,\n    num_mesh, degree;\n    x0 = x0,\n    l0 = t1 - t0,\n    de_args = [Tsit5()],\n)  As the limit cycle is only approximately specified, solver option  start_from_nearest_root = true  must be passed to start continuation:  solver = init(\n    prob;\n    start_from_nearest_root = true,\n)\n@time solve!(solver)  372.495524 seconds (9.02 M allocations: 1.285 GiB, 0.93% gc time)\nBifurcationSolver  Continuous \n# sweeps             : 2\n# points             : 35\n# branches           : 0  By default,  plot_state_space  plots limit cycles colored by its period:  plt_lc = plot_state_space(solver)", 
            "title": "Continuation of limit cycles of the van der Pol oscillator"
        }, 
        {
            "location": "/examples/morris_lecar/", 
            "text": "Modified Morris-Lecar model\n\n\nModified Morris-Lecar model from \nDhooge, Govaerts, Kuznetsov (2003)\n:\n\n\n\n\nDhooge, Govaerts, Kuznetsov (2003)\n. Numerical Continuation of Fold Bifurcations of Limit Cycles in MATCONT\n\n\n\n\nusing Bifurcations\nusing Bifurcations: special_points\nusing Bifurcations.Codim1\nusing Bifurcations.Codim2\nusing Bifurcations.Codim2LimitCycle: FoldLimitCycleProblem\nusing Bifurcations.Examples: MorrisLecar\n\nusing Setfield: @lens\nusing Plots\n\n\n\n\nSolve continuation of the equilibrium point:\n\n\nsolver = init(\n    MorrisLecar.make_prob();\n    start_from_nearest_root = true,\n    max_branches = 0,\n    nominal_angle_rad = 2\u03c0 * (5 / 360),\n)\n@time solve!(solver)\n\n\n\n\n  0.998282 seconds (1.81 M allocations: 97.573 MiB, 5.17% gc time)\nCodim1Solver \nContinuous\n\n# sweeps             : 2\n# points             : 41\n# branches           : 0\n# saddle_node        : 2\n# hopf               : 1\n\n\n\n\nPlot equilibriums in $(u_1, y)$-space:\n\n\nplt1 = plot(solver)\n\n\n\n\n\n\n\n\nStart continuation of Hopf bifurcation\n\n\nhopf_point, = special_points(solver, Codim1.PointTypes.hopf)\n\n\n\n\n1-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim1.PointTypes.PointType,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{2,3},Float64,2,6}},1}:\n SpecialPointInterval \nContinuous hopf\n\nhappened between:\n  u0 = [0.0407794, 0.306436, 0.0883504]\n  u1 = [0.0314239, 0.279715, 0.0601626]\n\n\n\n\nSolve continuation of the Hopf point:\n\n\ncodim2_prob = BifurcationProblem(\n    hopf_point,\n    solver,\n    (@lens _.z),\n    (-1.0, 1.0),\n)\nhopf_solver1 = init(\n    codim2_prob;\n    nominal_angle_rad = 0.01,\n)\n@time solve!(hopf_solver1)\n\n\n\n\n 18.487023 seconds (40.67 M allocations: 2.029 GiB, 7.76% gc time)\nCodim2Solver \nContinuous\n\n# sweeps             : 2\n# points             : 55\n# branches           : 0\n# bautin             : 1\n\n\n\n\n\n\nStart continuation of fold bifurcation of limit cycle at Bautin bifurcation\n\n\nbautin_point, = special_points(hopf_solver1, Codim2.PointTypes.bautin)\n\n\n\n\n1-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim2.PointTypes.PointType,StaticArrays.SArray{Tuple{9},Float64,1,9},StaticArrays.SArray{Tuple{8,9},Float64,2,72}},1}:\n SpecialPointInterval \nContinuous bautin\n\nhappened between:\n  u0 = [0.0298965, 0.350792, 0.367924, 0.382807, 0.82458, -0.195343, 2.0067, 0.165926, 0.0745246]\n  u1 = [0.0295841, 0.35324, 0.367212, 0.382471, 0.824988, -0.19562, 2.01059, 0.169869, 0.0734342]\n\n\n\n\nConstruct a problem for fold bifurcation of the limit cycle starting at \nbautin_point\n:\n\n\nflc_prob = FoldLimitCycleProblem(\n    bautin_point,\n    hopf_solver1;\n    period_bound = (0.0, 14.0),  # see below\n    num_mesh = 120,\n    degree = 4,\n)\nflc_solver = init(\n    flc_prob;\n    start_from_nearest_root = true,\n    max_branches = 0,\n    bidirectional_first_sweep = false,\n    nominal_angle_rad = 2\u03c0 * (5 / 360),\n    max_samples = 500,\n)\n@time solve!(flc_solver)\n\n\n\n\n1142.253670 seconds (218.78 M allocations: 36.352 GiB, 2.44% gc time)\nBifurcationSolver \nContinuous\n\n# sweeps             : 1\n# points             : 46\n# branches           : 0\n\n\n\n\nPlot the limit cycles at fold bifurcation boundaries:\n\n\nplt_state_space = plot_state_space(flc_solver)\n\n\n\n\n\n\nThe continuation was configured to stop just before the period is about to diverge.  Note that stopping at larger period requires larger mesh size.\n\n\nplt_periods = plot(flc_solver, (x=:p1, y=:period))\n\n\n\n\n\n\n\n\nStart continuation of Saddle-Node bifurcation\n\n\nsn_point, = special_points(solver, Codim1.PointTypes.saddle_node)\n\n\n\n\n2-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim1.PointTypes.PointType,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{2,3},Float64,2,6}},1}:\n SpecialPointInterval \nContinuous saddle_node\n\nhappened between:\n  u0 = [-0.0311873, 0.140701, -0.0206357]\n  u1 = [-0.0373, 0.130813, -0.0205553]\n\n SpecialPointInterval \nContinuous saddle_node\n\nhappened between:\n  u0 = [-0.23318, 0.00999542, 0.0828906]\n  u1 = [-0.247815, 0.00818325, 0.0832351]\n\n\n\n\nGoing back to the original continuation of the equilibrium, let's start continuation of one of the saddle-node bifurcation:\n\n\nsn_prob = BifurcationProblem(\n    sn_point,\n    solver,\n    (@lens _.z),\n    (-1.0, 1.0),\n)\nsn_solver = init(\n    sn_prob;\n    nominal_angle_rad = 0.01,\n    max_samples = 1000,\n    start_from_nearest_root = true,\n)\n@time solve!(sn_solver)\n\n\n\n\n  3.214664 seconds (5.26 M allocations: 284.247 MiB, 5.41% gc time)\nCodim2Solver \nContinuous\n\n# sweeps             : 2\n# points             : 385\n# branches           : 0\n# cusp               : 1\n# bogdanov_takens    : 1\n\n\n\n\n\n\nSwitching to continuation of Hopf bifurcation at Bogdanov-Takens bifurcation\n\n\nhopf_prob2 = BifurcationProblem(\n    special_points(sn_solver, Codim2.PointTypes.bogdanov_takens)[1],\n    sn_solver,\n)\nhopf_solver2 = init(hopf_prob2)\n@time solve!(hopf_solver2)\n\n\n\n\n  0.002418 seconds (4.01 k allocations: 698.188 KiB)\nCodim2Solver \nContinuous\n\n# sweeps             : 2\n# points             : 11\n# branches           : 0\n# bogdanov_takens    : 1\n\n\n\n\n\n\nPhase diagram\n\n\nplt2 = plot()\nfor s in [hopf_solver1, flc_solver, sn_solver, hopf_solver2]\n    plot!(plt2, s)\nend\nplot!(plt2, ylim=(0.03, 0.15), xlim=(-0.05, 0.2))", 
            "title": "Morris lecar"
        }, 
        {
            "location": "/examples/morris_lecar/#modified-morris-lecar-model", 
            "text": "Modified Morris-Lecar model from  Dhooge, Govaerts, Kuznetsov (2003) :   Dhooge, Govaerts, Kuznetsov (2003) . Numerical Continuation of Fold Bifurcations of Limit Cycles in MATCONT   using Bifurcations\nusing Bifurcations: special_points\nusing Bifurcations.Codim1\nusing Bifurcations.Codim2\nusing Bifurcations.Codim2LimitCycle: FoldLimitCycleProblem\nusing Bifurcations.Examples: MorrisLecar\n\nusing Setfield: @lens\nusing Plots  Solve continuation of the equilibrium point:  solver = init(\n    MorrisLecar.make_prob();\n    start_from_nearest_root = true,\n    max_branches = 0,\n    nominal_angle_rad = 2\u03c0 * (5 / 360),\n)\n@time solve!(solver)    0.998282 seconds (1.81 M allocations: 97.573 MiB, 5.17% gc time)\nCodim1Solver  Continuous \n# sweeps             : 2\n# points             : 41\n# branches           : 0\n# saddle_node        : 2\n# hopf               : 1  Plot equilibriums in $(u_1, y)$-space:  plt1 = plot(solver)", 
            "title": "Modified Morris-Lecar model"
        }, 
        {
            "location": "/examples/morris_lecar/#start-continuation-of-hopf-bifurcation", 
            "text": "hopf_point, = special_points(solver, Codim1.PointTypes.hopf)  1-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim1.PointTypes.PointType,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{2,3},Float64,2,6}},1}:\n SpecialPointInterval  Continuous hopf \nhappened between:\n  u0 = [0.0407794, 0.306436, 0.0883504]\n  u1 = [0.0314239, 0.279715, 0.0601626]  Solve continuation of the Hopf point:  codim2_prob = BifurcationProblem(\n    hopf_point,\n    solver,\n    (@lens _.z),\n    (-1.0, 1.0),\n)\nhopf_solver1 = init(\n    codim2_prob;\n    nominal_angle_rad = 0.01,\n)\n@time solve!(hopf_solver1)   18.487023 seconds (40.67 M allocations: 2.029 GiB, 7.76% gc time)\nCodim2Solver  Continuous \n# sweeps             : 2\n# points             : 55\n# branches           : 0\n# bautin             : 1", 
            "title": "Start continuation of Hopf bifurcation"
        }, 
        {
            "location": "/examples/morris_lecar/#start-continuation-of-fold-bifurcation-of-limit-cycle-at-bautin-bifurcation", 
            "text": "bautin_point, = special_points(hopf_solver1, Codim2.PointTypes.bautin)  1-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim2.PointTypes.PointType,StaticArrays.SArray{Tuple{9},Float64,1,9},StaticArrays.SArray{Tuple{8,9},Float64,2,72}},1}:\n SpecialPointInterval  Continuous bautin \nhappened between:\n  u0 = [0.0298965, 0.350792, 0.367924, 0.382807, 0.82458, -0.195343, 2.0067, 0.165926, 0.0745246]\n  u1 = [0.0295841, 0.35324, 0.367212, 0.382471, 0.824988, -0.19562, 2.01059, 0.169869, 0.0734342]  Construct a problem for fold bifurcation of the limit cycle starting at  bautin_point :  flc_prob = FoldLimitCycleProblem(\n    bautin_point,\n    hopf_solver1;\n    period_bound = (0.0, 14.0),  # see below\n    num_mesh = 120,\n    degree = 4,\n)\nflc_solver = init(\n    flc_prob;\n    start_from_nearest_root = true,\n    max_branches = 0,\n    bidirectional_first_sweep = false,\n    nominal_angle_rad = 2\u03c0 * (5 / 360),\n    max_samples = 500,\n)\n@time solve!(flc_solver)  1142.253670 seconds (218.78 M allocations: 36.352 GiB, 2.44% gc time)\nBifurcationSolver  Continuous \n# sweeps             : 1\n# points             : 46\n# branches           : 0  Plot the limit cycles at fold bifurcation boundaries:  plt_state_space = plot_state_space(flc_solver)   The continuation was configured to stop just before the period is about to diverge.  Note that stopping at larger period requires larger mesh size.  plt_periods = plot(flc_solver, (x=:p1, y=:period))", 
            "title": "Start continuation of fold bifurcation of limit cycle at Bautin bifurcation"
        }, 
        {
            "location": "/examples/morris_lecar/#start-continuation-of-saddle-node-bifurcation", 
            "text": "sn_point, = special_points(solver, Codim1.PointTypes.saddle_node)  2-element Array{Bifurcations.BifurcationsBase.SpecialPointInterval{Bifurcations.BifurcationsBase.Continuous,Bifurcations.Codim1.PointTypes.PointType,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{2,3},Float64,2,6}},1}:\n SpecialPointInterval  Continuous saddle_node \nhappened between:\n  u0 = [-0.0311873, 0.140701, -0.0206357]\n  u1 = [-0.0373, 0.130813, -0.0205553]\n\n SpecialPointInterval  Continuous saddle_node \nhappened between:\n  u0 = [-0.23318, 0.00999542, 0.0828906]\n  u1 = [-0.247815, 0.00818325, 0.0832351]  Going back to the original continuation of the equilibrium, let's start continuation of one of the saddle-node bifurcation:  sn_prob = BifurcationProblem(\n    sn_point,\n    solver,\n    (@lens _.z),\n    (-1.0, 1.0),\n)\nsn_solver = init(\n    sn_prob;\n    nominal_angle_rad = 0.01,\n    max_samples = 1000,\n    start_from_nearest_root = true,\n)\n@time solve!(sn_solver)    3.214664 seconds (5.26 M allocations: 284.247 MiB, 5.41% gc time)\nCodim2Solver  Continuous \n# sweeps             : 2\n# points             : 385\n# branches           : 0\n# cusp               : 1\n# bogdanov_takens    : 1", 
            "title": "Start continuation of Saddle-Node bifurcation"
        }, 
        {
            "location": "/examples/morris_lecar/#switching-to-continuation-of-hopf-bifurcation-at-bogdanov-takens-bifurcation", 
            "text": "hopf_prob2 = BifurcationProblem(\n    special_points(sn_solver, Codim2.PointTypes.bogdanov_takens)[1],\n    sn_solver,\n)\nhopf_solver2 = init(hopf_prob2)\n@time solve!(hopf_solver2)    0.002418 seconds (4.01 k allocations: 698.188 KiB)\nCodim2Solver  Continuous \n# sweeps             : 2\n# points             : 11\n# branches           : 0\n# bogdanov_takens    : 1", 
            "title": "Switching to continuation of Hopf bifurcation at Bogdanov-Takens bifurcation"
        }, 
        {
            "location": "/examples/morris_lecar/#phase-diagram", 
            "text": "plt2 = plot()\nfor s in [hopf_solver1, flc_solver, sn_solver, hopf_solver2]\n    plot!(plt2, s)\nend\nplot!(plt2, ylim=(0.03, 0.15), xlim=(-0.05, 0.2))", 
            "title": "Phase diagram"
        }
    ]
}